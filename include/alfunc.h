#include "mtype.h"
#include "mklib.h"
#include "lock.h"
#include "process.h"
#include "fs.h"
#include "fat12.h"
#include "fdc.h"
#include "ne2k.h"
#include "semaphore.h"
#include "packet.h"
#include "socket.h"
#include "pthread.h"

int fat12_vop_destroy(struct vnode *vn);
void read_fat12(struct vfs *fs, int dev);
void cluster2param12(struct vfs *fs, int clno, int *head, int *track, int *sector);
int fat12_vop_open(struct vnode *vn, int flags, mode_t mode);
int fat12_vop_close(struct vnode *vn);
int fat12_vop_read(struct vnode *vn, int offset, char *buf, int nb);
int fat12_vop_write(struct vnode *vn, int offset, char *buf, int nb);
int fat12_vop_getattr(struct vnode *vn, struct stat *buf);
int fat12_vop_setattr(struct vnode *vn, struct stat *stbuf);
struct vnode * fat12_vop_lookup(struct vnode *dvn, const char *name);
struct vnode * fat12_vop_create(struct vnode *dvn, const char *fname, mode_t mode);
int fat12_vop_trunc(struct vnode *vn);  
int fat12_vop_remove(struct vnode *dvn);
int fat12_vop_rename(struct vnode *sdvn, struct vnode *ddvn, const char *nname);
int fat12_vop_mkdir(struct vnode *dvn, const char *dirname, mode_t mode);
int fat12_vop_rmdir(struct vnode *dvn, const char *dirname);
int fat12_vop_opendir(struct vnode *vn);
int fat12_vop_closedir(struct vnode *vn);
int fat12_vop_readdir(struct vnode *vn, int offset, struct dirent *ind_dirp, char *dep_dirp);
off_t fat12_vop_telldir(struct vnode *vn);
int fat12_vop_link(struct vnode *sdvn, const char *srcpathname, struct vnode *ddvn, const char *targetpathname);
int fat12_vop_symlink(struct vnode *sdvn, const char *srcpathname, struct vnode *ddvn, const char *targetpathname);
int fat12_vop_readlink(struct vnode *vn, char *buf, size_t bufsiz);
int fat12_vop_ioctl(struct vnode *vn, int request, ...);
int fat12_vop_access(void);
int fat12_vop_inactive(void);
int fat12_vop_rwlock(struct vnode *vn, int lcktype);
int fat12_vop_rwunlock(struct vnode *vn);
int fat12_vop_realvp(void);
int fat12_vop_getpage(void);
int fat12_vop_putpage(void);
int fat12_vop_map(void);
int fat12_vop_poll(void);
int fat12_vfs_mount(struct vnode *svn, struct vfs *dvfs, struct vnode *dvn);
int fat12_vfs_unmount(struct vnode *svn, struct vnode *dvn);
struct vnode * fat12_vfs_root(struct vnode *vn);
int fat12_vfs_sync(struct vnode *vn);
int syscall_sync(int dev);
void write_fat12(int dev);
int fat12_vfs_statvfs(struct vnode *vnroot, struct vfsinfo *inf);
int fat12_vop_seekdir(struct vnode *vn, int offset);
int fat12_vop_seek(struct vnode *vn, int offset, int pos, int whence);

void motor_on( FDD *fdd );
void motor_off( FDD *fdd );
void fdc_intr_handler(int n);
void fdc_reset( FDC *fdc );
int setup_drive( FDD *fdd );
int fdc_setup( FDD *fdd );
void reset_drive( FDD *fdd );
int fdc_read( FDD *fdd, const Chs *chs, DWORD buffer, unsigned num_sectors );
int fdc_write( FDD *fdd, const Chs *chs, const DWORD buffer, unsigned num_sectors );
int fdc_format(FDD *fdd);
void fdcDispose(void);
void initialize_floppy_request_bufs(void);
struct floppy_request *enqueue_floppy_request(char device, unsigned long lba, unsigned blocks, void *buffer, int op);
void dequeue_floppy_request(struct floppy_request *dr);
int floppy_read(FDD *fdd, unsigned start, unsigned count, void *buffer);
int floppy_write(FDD *fdd, unsigned start, unsigned count, const void *buffer);
int floppy_format(FDD *fdd);
int floppy_setup(FDD *fdd);
void floppy_thread(void);
int alloc_ftab_slot(void);
int alloc_process_file_handle(int ft_handle);
void get_vnode(struct vnode *vn);
void release_vnode(struct vnode *vn);
void delete_vnode(struct vnode *vn);
int read_block(char device, unsigned int blk, char *data);
int syscall_writeblocks(char device, unsigned int startblk, int count, char *buf);
int syscall_readblocks(char device, unsigned int startblk, int count, char *buf);
int write_block(char device, unsigned int blk, char *data);
void increment_ref_count(int dir_handle);
void decrement_ref_count(int handle);
struct vnode * lookup_path(const char *path);
void parse_path(const char *path, char *dir_path, char *name_comp);
struct vnode * get_rootdir(void);
struct vnode * get_curdir(void);
struct vnode * get_pdir(struct vnode *vn);
int valid_handle(int handle, int flags);
int syscall_open(const char *path, int type, mode_t mode);
int syscall_close(int fhandle);
int syscall_write(int handle, void *buf, size_t nbytes);
int syscall_creat(const char *path, mode_t mode);
off_t syscall_lseek(int fildes, off_t offset, int whence);
int dup(int oldfd);
int dup2(int oldfd, int newfd);
DIR * syscall_opendir(const char *path, DIR *dir);
int syscall_closedir(DIR *dir);
struct dirent * syscall_readdir(DIR *dir);
void syscall_seekdir(DIR *dir, off_t offset);
off_t syscall_telldir(DIR *dir);
void syscall_rewinddir(DIR *dir);
int syscall_mkdir(const char *path, mode_t mode);
int syscall_rmdir(const char *path);
int syscall_chdir(const char *path);
int syscall_fchdir(int fd);
int syscall_unlink(const char *path);
int syscall_rename(const char *a_oldpath, const char *a_newpath);
int syscall_stat(const char *path, struct stat *buf);
int syscall_chmod(const char *pathname, mode_t mode);
int syscall_getcharf(int fd);
int syscall_ungetcharf(int c, int fd);
struct vnode * mountroot(void);
int vnode_add_hashlist(struct vnode *vn);
int vnode_del_hashlist(struct vnode *vn);
struct vnode * alloc_vnode(dev_t dev, int vno, struct vnode * pvn, int offset, size_t size);
void initialize_buffer_cache(void);
struct buffer_header * getblk(char device,unsigned long blockno);
void brelease( struct buffer_header * b);
struct buffer_header* bread(char device,unsigned long blockno);
void flush_buffers(void);
void kbd_intr_handler(int irq);
int insertkb_char(int c);
int syscall_getchar(void);
int syscall_getchare(void);
int syscall_getscanchar(void);
void kbd_init(void);
void lockobj_init(struct lock_t *l);
void rlockobj_init(struct rlock_t *rl);
void eventobj_init(struct event_t *e);
int _lock(struct lock_t *l);
int trylock(struct lock_t *l);
int unlock(struct lock_t * l);
int rlock(struct rlock_t *l);
int runlock(struct rlock_t * l);
int event_wakeup(struct event_t *e);
int event_sleep(struct event_t *e, struct lock_t *lck);
int event_wait_remove_thread(void *arg);
int event_timed_sleep(struct event_t *e, struct lock_t *lck, unsigned int msecs);
int sys_unlock(struct lock_t *l);
int sys_event_wakeup(struct event_t *e);

void mount_thread(void);
void fat_updater(void) ;
int mksysthread(void (* func)(void), char thrname[], int priority, unsigned short threadno);
void create_shell_process(void);
void bsend(void);
void brecv(void);
void dummythread(void);
void dummythread1(void);
void display_file(void);
void init_system_service_thread(void);
void cmain(void);
void get_sys_data(void);

int readlinef(int fd, char buf[], int maxchar);
int syscall_change_datasegment_size(unsigned int oldenddataaddr, unsigned int newenddataaddr, int param);
struct process * LocateProcess(int procid);
void nic_isr(int irq) ;
void free_frame_buffer(frame_buffer *newframe);
void nicthread_setup(void);
void syscall_machid(void);
void nicthread(void);
void disp_debuginfo(struct process *proc);

int OLRC_UpdatePage(struct process *proc, struct kthread *thr, int pageno, void *param);





void idlethread_routine(void);
void initialize_systemprocess(void);
void terminate_systeminit_thread(void);
int create_process(struct process_param *tparam, char *name, int type, int mctype, int priority, unsigned short procno);
int create_thread(struct process *proc, char thrname[], int scid, int priority, unsigned long stck_top, unsigned long start_routine, short threadno);
void add_readyq(struct kthread *thr);
int del_readyq(struct kthread *thr);
int inherit_priority(volatile struct kthread *thr, int pri);
void thread_exit(void);
int terminate_thread(struct kthread *t);
void thread_terminate_handler(void);
void terminate_process(struct process *p);
struct kthread *alloc_thread(void);
void destroy_thread(struct kthread *t);
struct rthread * alloc_rthread_slot(void);
void halt_system(void);
void suspend(struct process *proc);
void wakeup(struct kthread *t);
void initialize_ldt(struct LDT *ldt, struct process_param *tparam, int type) ;
int create_thread_in_proc(struct process *proc, void *attr, void * (*start_routine)(void *), void *arg, unsigned int stackstart, unsigned int initialstacksize, int thrid);
int exectask_internal(char pathname[], char *argv[], char *envp[], int type, int local, void *(* start_routine)(void *), void *arg, unsigned int dssize, unsigned int stack_start, unsigned int initial_stacksize, int pno, int thrno, int srcmachine, int mctype, int commid);
int syscall_exectask(char pathname[], char *argv[], char *envp[], int type);
void syscall_exit(int status);
int syscall_getpids(int pid[], int n);
int syscall_getprocinfo(int pid, struct uprocinfo *pinf);
int syscall_wait(int *status);
int syscall_kill(int pid);
struct kthread * initialize_irqtask(int irqno, char *tname, void (* irq_handler_func)(void), int pri);
int syscall_pageinfo(int pid, unsigned int pageno);
void do_divide_error(struct PAR_REGS * regs, int error_code);
void do_coprocessor_error(struct PAR_REGS * regs, int error_code);
void do_device_not_available(struct PAR_REGS *regs, int error_code);
void do_simd_coprocessor_error(struct PAR_REGS *regs, int error_code);
void do_debug(struct PAR_REGS *regs, int error_code);
void do_nmi(struct PAR_REGS *regs, int error_code);
void do_inter3(struct PAR_REGS *regs, int error_code);
void do_overflow(struct PAR_REGS *regs, int error_code);
void do_bounds(struct PAR_REGS * regs, int error_code);
void do_invalid_TSS(struct PAR_REGS * regs, int error_code);
void do_invalid_op(struct PAR_REGS * regs, int error_code);
void do_coprocessor_segment_overrun(struct PAR_REGS *regs, int error_code);
void do_double_fault(struct PAR_REGS *regs, int error_code);
void do_segment_not_present(struct PAR_REGS * regs, int error_code);
void do_stack_segment( struct PAR_REGS * regs, int error_code);
void do_general_protection(struct PAR_REGS * regs, int error_code);
void do_alignment_check(struct PAR_REGS *regs, int error_code);
void do_machine_check(struct PAR_REGS *regs, int error_code);
void do_spurious_interrupt_bug(struct PAR_REGS * regs, int error_code);
void do_page_fault(struct PAR_REGS *regs, int error_code);

void set_irq_gate(int irq_no,void (*handler)(int));
void default_irq_handler(int irq_no);
void do_unhandled_interrupt(struct PAR_REGS *regs, int vector_no);
void irq_handler(struct PAR_REGS *regs, int irq_no);
void math_emulate(struct PAR_REGS *regs, int error_code);
int semobj_init(struct semtable_entry *s_ent, int pshared, int val);
int syscall_sem_init(sem_t *sem, int pshared, unsigned int val);
int syscall_sem_destroy(sem_t *sem);
sem_t * syscall_sem_open(const char *name, int oflag, mode_t mode, unsigned int value, sem_t *sem);
int syscall_sem_close(sem_t *sem);
int syscall_sem_unlink(const char *name);
int syscall_sem_wait(sem_t *sem);
int syscall_sem_trywait(sem_t *sem);
int removethread_fromsemwait(void *varg);
int syscall_sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
int syscall_sem_post(sem_t *sem);
int syscall_sem_getvalue(sem_t *sem, int *val);
int get_processid(void) ;
int get_threadid(void);
unsigned short checksum(char *buf1, int len1, char *buf2, int len2, char *buf3, int len3);
void initialize_recvpkts(void);
int alloc_pktindex(struct eth_frame_rcv *ef);
void free_packet(struct packet *pkt);
struct proc_sock * locate_socket(int portno, int type);
int remove_pkt(void *arg);
int pktindex(struct eth_frame_rcv *ef);
void initialize_hash_table(void);

void add_hash_node(int host,int port, int type, int packet_id);
void purge_seqno_hashtable(int before);
void seqno_init(int host, int port, int type, int pkt_id);
void initialize_socktable(void);
void increment_sockref_count(int handle) ;
void decrement_sockref_count(int handle);
int syscall_broadcast(int portno, char *buf, int len);
int syscall_tsendto(short dest_threadid, char *buf, unsigned int len, int groupid, int tag, short nb);
int local_broadcast(struct isockaddr * destsock, struct isockaddr *srcsock, char *buf, unsigned int len, int pkt_seqno, int groupid, int tag);
int internal_tsend(struct isockaddr * destsock, struct isockaddr *srcsock, char *buf, unsigned int len, int groupid, int tag, short nb);
int sock_broadcast(char *buf, int len, short nb);
int psock_send_pkt(struct proc_sock *psock, struct frame_buffer *swin_frame_buf, struct eth_frame_snd *swin_frame);
void pkttransmitter(void);
void delete_socket(struct proc_sock *psock);
int send_seqnumber_mesg(int sourcemachine, int sourceport, int socktype);
void send_ack(int type,struct eth_frame_rcv *ef, unsigned short expect_winseqno, unsigned int offset);
int remove_frames_fromtxq(int pkt_id, int offset, int srcport, int srctype, int pktttype);
void process_ack(struct packet *pkt, struct eth_frame_rcv *rcvd_eth_frame);
void packet_type_data(struct frame_buffer *rcvd_frame_buf);
void assemble(void);
int deliver_packet(int ind);
int syscall_trecvfrom(char buf[], int maxlen, short *from, int nb);
int trecvfrom_internal(char buf[], int maxlen, short *from, int nb, int pkttype, int groupid, int *tag, int wmsec);
struct proc_sock * create_defsock(int portno);
int syscall_socket(int family, int type, int protocol);
int syscall_bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
int recv_fromsock_stream(struct proc_sock *psk, char *buf, int maxlen, int flags);
int recv_fromsock_dgram(struct proc_sock *psk, struct isockaddr *from, char *buf, int maxlen, int flags);
int syscall_recv(int s, void *buf, size_t len, int flags);
int syscall_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);
int sock_send(struct proc_sock *psock, struct isockaddr *dest, const char *buf, unsigned int len, int pkttype, int groupid, int tag, int nb);
int syscall_send(int s, const void *buf, size_t len, int flags);
int syscall_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
int syscall_connect(int s, const struct sockaddr *serv_addr, socklen_t addrlen);
int syscall_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
int syscall_listen(int s, int backlog);
int syscall_close_socket(int s);
void dump_frame(struct eth_frame_rcv *eframe);
void dump_packet(struct packet *pkt);
void display_sockets(void);
char *strcat(char *dest, const char *src);
int strcmp(const char *dest, const char *src);
int strlen(const char *src);
int strnlen(const char *src, int n);
char *strncpy(char *dest, const char *src,unsigned int n);
char *strncat(char *dest, const char *src,unsigned int n);
int strncmp(const char *dest,const char *src,unsigned int n);
int toupper(int ch);
int tolower(int ch);
int isspace(int ch);
int isalpha(int ch);
int isnum(int ch);
int isdigit(int ch);
int isxdigit(int ch);
char *strstr (register char *buf, register char *sub);
char *strchr(const char *s, int c);
int syscall_test(void);
int systemcall(struct PAR_REGS *regs);
int syscall_notimplemented(int num);
void rr_cl_tick(struct kthread *thr);
void rr_cl_sleep(struct kthread *thr);
void rr_cl_wakeup(struct kthread *thr);
void rr_cl_fork(struct kthread *thr);
void rr_cl_forkret(struct kthread *thr);
void rr_cl_enterclass(struct kthread *thr);
void rr_cl_exitclass(struct kthread *thr);
void timer_handler (int irq);
void scheduler(void);
void syscall_tsleep(unsigned int msec);
time_t syscall_ptime(time_t *t);
time_t syscall_time(time_t *t);
void timer_init(void);
void timerobj_init(struct timerobject *tobj);
int starttimer(struct timerobject *tobj, unsigned long msec, int (*timeouthandler)(void *), void *handlerparam);
int stoptimer(struct timerobject *tobj);
void timerthread(void);
int syscall_gettsc(unsigned int *hi, unsigned int *lo, unsigned int *msecs);
struct date_time secs_to_date(unsigned int secs);
unsigned int date_to_secs(struct date_time dt);
void context_switch(struct kthread * new_thread);
void debug_mesg(int addr);
void video_init(void);
int syscall_putchar(char c);
int syscall_puts(char *str);
void syscall_setcursor(int x, int y);
void output_proc(char *text, int len);
void scroll_up(int lines);
void scroll_down(int lines);
void change_screen(struct process *newprocess);
struct video_param get_video_param(void);
int set_video_param(struct video_param * vp);
int skip_atoi(const char **s);
char * number(char * str, long num, int base, int size, int precision, int type);
int vsprintf(char *buf, const char *fmt, va_list args);
int sprintf(char * buf, const char *fmt, ...);
int printk(const char * fmt, ...);
int print_p(const char *fmt, ...);
int print_context(struct PAR_REGS *regs, int error_code);
struct vm * vm_createvm(void);
int vm_destroy(struct vm *vmem);
int vm_addregion(struct vm *vmem, short type, unsigned int lstart, unsigned int lend, short ptflag, short memflag);
int vm_delregionend(struct vm *vmem, unsigned int lend);
int vm_delregion(struct vm *vmem, unsigned int lstart);
int vm_expandregion(struct vm *vmem, unsigned int lstart, unsigned int size, short pgflag, short memflag);
int vm_expanddownregion(struct vm *vmem, unsigned int lstart, unsigned int lend, short pgflag, short memflag);
int vm_shrinkregion(struct vm *vmem, unsigned int lstart, unsigned int size);
struct memsegment * vm_getmemsegment(struct memregion *mreg);
int vm_releasesegment(struct memsegment *mseg);
int vm_attachmemsegment(struct memregion *mreg, struct memsegment *msegment);
int vm_detachmemsegment(struct memregion *mreg);
PTE* vm_getptentry(struct vm *vmem, unsigned int lpage);
PDE* vm_getpdentry(struct vm *vmem, unsigned int lpage);
int vm_setattr(struct vm *vmem, unsigned int lpage, int *avail, int *rw, int *present, int *global, int *accessed, int *dirty);
int vm_getdirtylist(struct vm *vmem, int *buf, int size, int type);
int vm_getaccesslist(struct vm *vmem, int *buf, int size, int type);
int vm_getattr(struct vm *vmem, unsigned int lpage, int *avail, int *rw, int *present, int *global, int *accessed, int *dirty);
void make_page_table(PageTable *pt, int start_index, int nentries, unsigned long shifted_phys_address, unsigned char attr, unsigned char rw, unsigned char present, unsigned char global);
void initialize_kernel_pagetables(void);
int phys2vmcopy(char *src, struct vm *dvm, char *dest, int nbytes);
int vm2physcopy(struct vm *svm, char *src, char *dest, int nbytes);
int vm2vmcopy(struct vm *svm, char *src, struct vm *dvm, char *dest, int nbytes);
int lock_page(PageDir *pd, char *logaddr);
int unlock_page(PageDir *pd, char *logaddr);
char *logical2physical(PageDir *pd, char *logicaladdr);
struct core_header core_alloc(int npages);
int core_alloc_n(int npages, struct core_header ch[], int chmax);
void core_free(struct core_header ch);
void core_init(char *first_free_loc);
void *kmalloc(unsigned int size);
void kfree(void *ptr);
int syscall_brk(void *end_data_addr);
int alloc_frame_memory(struct process *proc, unsigned int pageno);
void initialize_gdt(void);
void initialize_codeseg(struct segdesc_s *segdp, unsigned int base, unsigned int size, int privilege);
void initialize_dataseg(struct segdesc_s *segdp, unsigned int base, unsigned int size, int privilege);
void sdesc(struct segdesc_s *segdp, unsigned int base, unsigned int size);
int syscall_prifree(void *addr, unsigned int size);
int syscall_primalloc(unsigned int size);
void print_tss(void);
void disp_PTE(	PageTable *pt, unsigned int i);
void disp_page_table(PageTable *pt, int nent);
void disp_page_dir(PageDir *pd);
void print_core_info(void);
void print_ramsegments(void);
void print_list(struct mem_list *l);
void print_gdt(int start, int n);
void print_minf_statistics(void);

int syscall_pthread_create(pthread_t *threadp, const pthread_attr_t *attr, void *(* start_routine)(void *), void * arg);
pthread_t syscall_pthread_self (void);
int pthread_equal (pthread_t thread1, pthread_t thread2);
void syscall_pthread_exit (void *retval);
int syscall_pthread_join (pthread_t th, void **thread_return);
int syscall_pthread_detach (pthread_t th);
int syscall_pthread_yield (void);
int syscall_pthread_mutex_init (pthread_mutex_t *__restrict mutex, __const pthread_mutexattr_t *__restrict mutex_attr) ;
int pthread_mutex_destroy (pthread_mutex_t *mutex);
int syscall_pthread_mutex_trylock (pthread_mutex_t *mutex);
int syscall_pthread_mutex_lock (pthread_mutex_t *mutex) ;
int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime);
int syscall_pthread_mutex_unlock (pthread_mutex_t *mutex);
int pthread_mutexattr_init (pthread_mutexattr_t *__attr) ;
int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr);
int pthread_mutexattr_getpshared (__const pthread_mutexattr_t * __restrict __attr, int *__restrict __pshared);
int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr, int __pshared);
int syscall_pthread_cond_init (pthread_cond_t *__restrict cond, __const pthread_condattr_t *__restrict __cond_attr);
int syscall_pthread_cond_destroy (pthread_cond_t *cond);
int syscall_pthread_cond_signal (pthread_cond_t *cond);
int syscall_pthread_cond_broadcast (pthread_cond_t *cond);
int syscall_pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime);
int pthread_condattr_init (pthread_condattr_t *__attr) ;
int pthread_condattr_destroy (pthread_condattr_t *__attr);
int pthread_condattr_getpshared (__const pthread_condattr_t * __restrict __attr, int *__restrict __pshared);
int pthread_condattr_setpshared (pthread_condattr_t *__attr, int __pshared) ;
int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared);
int pthread_spin_destroy (pthread_spinlock_t *__lock);
int pthread_spin_lock (pthread_spinlock_t *__lock);
int pthread_spin_trylock (pthread_spinlock_t *__lock);
int pthread_spin_unlock (pthread_spinlock_t *__lock);
int syscall_pthread_barrier_init (pthread_barrier_t *__restrict barrier, __const pthread_barrierattr_t *__restrict __attr, unsigned int count);
int pthread_barrier_destroy (pthread_barrier_t *barrier) ;
int pthread_barrierattr_init (pthread_barrierattr_t *__attr) ;
int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr);
int pthread_barrierattr_getpshared (__const pthread_barrierattr_t * __restrict __attr, int *__restrict __pshared) ;
int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr, int __pshared);
int syscall_pthread_barrier_wait (pthread_barrier_t *barrier);




